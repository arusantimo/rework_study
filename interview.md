# 19.8.6

### 디자인 패턴의 종류 및 설명

- 생성패턴 (객체 생성에 관련된 패턴)
  - 추상팩토리 : 서로 관련성이 있는 객체를 묶어서 같은 관련성의 메소드를 상위로 올려 같이 관리하는 형태 (예로 비둘기, 까치 둘다 공통적으로 난다. 곤충 먹는다 > 상위 새라는 카테고리를 만들어서 제어)
  - 싱글턴 : 전역변수를 사용하지 않고 하나의 객체만 생성하고 어디에서든지 객체를 참조할 수 있게 함. (사과나무 같은 구조)

- 구조패턴 (객체의 조합에 관련된 패턴)
  - 콤포지트 : 여러개의 객체들로 구성된 복합 객체를 합쳐서 하나의 완성된 구성품이 되고 같은 인터페이스로 핸들링 되게 한다. (예로 마린, 파팻, 시즈탱크를 같이 선택해서 공격이라는 하나의 같은 메서드를 이용 할수 있다. 공격유닛이라는 같은 메서드를 가지고 있기 때문에)
  - 어뎁터 : 메소드를 주입시켜주는 패턴
  - 데코레이트 : 객체의 합성을 통해 기능을 완성시켜주는 패턴 (예로 치즈와 도우가 합쳐지면 피자가 된다. 그전엔 피자가 아니다. 먹기도 힘들다. 특성을 갖고 있지 않은 것이다.)
  - 객체 대신 어떤 행위를 대신 해주는 객체를 생성하는 패턴이다. (예 반복적인 작업을 대신 하기 위한 중계자로 모든 책임과 힘이 있지 않고 단적인 일만 할수 있는 제한적인 객체를 생성하려 활용 한다.)
- 행위패턴(객체 사이에서 연결성에 영향을 주어 해결하는 패턴)
  - 옵저버 : 1대 N의 연동성으로 의존관계를 구축하여 문제 해결
  - 스테이트 : 객체의 상태에 따른 행위 내용 변경으로 문제 해결
  - 커멘드 : 기능등을 캡슐화하고 은닉화 하여 여러가지일은 한가지 명령(연결된 함수)으로 해결

# 19.8.7

### 함수형 프로그래밍에 대한 의견
전통적으로 명령형 프로그래밍으로 개발되어 졌다. 상태를 변경하고 변경된 상태가 동작의 실행인 방법. 상태를 변경하는 것에 포커싱하기에 상태를 가진는 객체가 중요해졌고 변하는 상태의 주체가 중요하다. 메서드는 객체의 상태를 변경하기 위해서 이용한다. 즉 함수 패러미터로 전달해온 값으로만 변경하지 않을 수도 있고 결국 메서드를 가지고 있는 객체의 상태를 변경하려고 한다. 이건 함수형 프로그래밍이 아니다. 함수형프로그래밍은 커멘드패턴을 응용, 외부의 상태를 변경하면 안된다. 함수는 패러미터로 받은 값을 연산처리하고 원하는 데이터로 뱉어 내기만 하면 된다. 그런 함수의 연결로 사용자는 원하는 값을 얻는다. 가장 많이 사용하는 것이 rx, lodash, ramda 등이다.

왜 함수형을 사용하는 것인가? 이런 물음이 들수 있다. 여러가지 공부를 해본 결과 난 좀 더 안전한 프로그램을 위해서라는 정의를 내렸다. 우리는 어떤 행위를 할때 어떤 결과를 얻고 싶어서 한다. 그럼 우리가 원하는 결과는 과연 프로그램에게 원하는 것으로 되어라 일까 원하는 것을 줘일까 난 답은 후자에 가깝다고 생각한다. 그럼으로 원하는 답을 줘 너는 그대신 멀쩡해야되구.! 이런 것을 원하는 페러다임이 아닐까 싶다. 하지만 현실적으로 함수형으로만 프로그래밍을 짤수는 없다고 생각한다. 상태의 변경과 관찰이 없으면 앱은 핸드링하 기 너무 복잡해 진다. 난 개인적으로는 객체지향 프로그래밍을 좋아하는것 같다. 분류하고 상태를 변경하고 관찰하는 것은 좀 더 명확한 구조를 짤 수 있게 해준다. 하지만 상태의 변경으로 인한 사이드이팩트를 줄이는 것또한 중요핟다. 난 이런점에서 커멘드 패턴으로 하나의 액션으로 원하는 것을 행동한다. 그리고 그 행동은 관찰 가능해야 한다고 생각한다.

### 웹 어플리케이션 제작간 메모리 관리 고려 경험

메모리는 지금 당장 쓰기위해 (실행중에 필욯한) 정보를 저장하는 장치. 데이터를 순차적으로 검색하지 않고 바로 바로 찾을 수있고 속도가 빠르다. 그렇다면 프로그래밍상 메모리 누수는 어떤 의미일까. 현재 사용하고 있는 프로그램은 메모리에 올라가서 동작한다. 물론 디스크에 올려도 되겠지만 그렇다면 너무 실행속도가 느려지게 된다. 이유는 앞서 설명한 검색의 방법에 있다.
그러면 실행에 필요한 값은 할당되어 진다. 참조된다고 생각하면 된다. 그리고 사용후 필요없어진다고 판단되면 메모리에서 해제하면 된다. 전역변수 선언등이 메모리를 사용하는 예이다. 우리는 자바스크립트라는 고수준의 언어?를 사용하고 있다. 그리고 우리는 실행과정에 해석되는 인터프리터 언어를 사용한다. 이런 언어에는 가비지 컬랙터라는 기능이 내정되어 있다. 현재 스콥과 실행 과정 환경에서 메모리 할당을 추적 관찰하고 더이상 연결(관찰)되어 있지 않다고 판단되면 메모리에서 해제한다. 우리는 이런 과정을 가비지컬렉터가 해주고 있기때문에 신경을 안쓰기도 하는데 앞서 설명한바와 같이 가비지 컬렉터가 이런 과정을 관찰하고 추적하고 해제하는것 또한 비용이다. 그리고 우리가 사용할지 안할지에 대한 판단은 프로그램적으로 해결할수  없다. 우리가 미리 그렇게 설계를 해야 한다. 

메모리 누수를 막기 위한 방법으로는
1. 전역 변수를 아무 목적없이 만들지 말아야 한다.
2. 웹 api함수가 비동기적 혹은 구동 내에 실행되지 않는 실행중일때 적절한 타이밍해 중지 시켜준다.
3. dom을 참조하는 경우 그 돔노드가 삭제되어도 게속 참조되고 있기때문에 해제해 줘야 한다. 이벤트리스너 또한 마찬가지로 해제
4. 함수 내에서 외부 변수를 참조하면 안됨 클로저(.....) 가비지 컬릭터가 수집하지 않게 된다. 함수는 언제든 실행할 수 있기 때문이다. 비공개 변수를 만들수 잇지만.. 한편으로는 그 비공개 변수는 메모리에서 해제가 되지 않는다. 비공개를 위한 상자안에 들어가 있어야 하기 때문? 이다.

### 호이스팅, 클로저 설명

호이스팅은 변수 선언이 함수 안에서는 회상위 밖에ㅔ서는 전역 컨텍스트 최상위로 변경 됨.
클로저는 함수 내부에 선언된 함수다. 클로저를 알기 위해선 스코프(스코프체인) / 컨텍스트 / 비공개 변수에 대한 이해가 필요하다.

### Event Delegation, 버블링 설명

돔에 이벤트리스너를 걸어서 관찰하려 한다. 이걸 등록이란 절차라고 한다면, 요소는 보통 겹쳐 있는 경우가 잇는데 그러면 하위 에 있는 요소위에 상위의 요소가 같이 이벤트가 전파된다. 이건 브라우저 이벤트 감지의 특성이다. 현재 이벤트가 일어나는 곳 이외에 이벤트 감지를 막기 위해서는 현재이벤트타겟에 stopPropagation 함수를 같이 실행해 주면 된다.

Delegation 즉 위임은 요소에 바로 이벤트 구독을 하지 않고 상위요소에서 하위요소의 이벤트를 구독하는 것이다. 이런 방법은 동적 요소 제어에서 자주 쓰일 것이다.


### Promise, Async/Await, Generator 설명
단일 스레스와 콜스택 이벤트 루프를 알아야 한다. 일단
프로미스는 비동기 적으로 처리할수 있는 함수라고 생각하면 된다. 보통 ajax 요청 후 반환 하는 객체가 프로미스인데 이벤트큐에 있다가 응답이 오면 이벤트 루프에서 콜스택으로 밀어넣어 진다. 프로미스 객체는 3가지 상태르 갖는다. 대기, 성공, 실패 비동기 코드를 짜기위해서 우리는 콜백을 사용하기 보단 프로미스로 비공기 코드를 짜는것이 좋다. 하지만 
이이후에 나온것이 async await다. async await는 프로미스에 비해 코드가 더 간결하고 일반 함수와 같은 형태를 띤다. 
또 다른 차이로는 일단적으로 사용하는 에러 체크 로직인 try catch 구문을 사용하여 에러 핸들링을 한다. 이러면 에러의 위치와 상태 파악이 빠르다. 
제너레이터는 함수는 비동기적 코드는 아니고 동기적 코드이다. async await의 문법과 유사성을 띄지만 비동기적이진 않다. 
물론 제너레이터와 프로미스함수를 섞는다면 비동기 코드를 짤수 있긴하다. 하지만 async await보다 강력하지 않다. 그렇다면 이건 어디에 써야 할까 동기적으로 함수가 실행되고 그 값을 컨르롤 해야 하는 순간에 사용가능하다. 즉 이터레이팅하는 순간순간마다. 값을 변경하는 것을 제너레이터라는 놈이 하게 만들어 보자는 취지였던거 같다. 함수는 한개의 데이터를 핸들링 하지만 제너레이터는 여러개의 값을 핸들링 하는것이다. 

### Prototype 기반 프로그래밍의 단점이 있다면?

프로토타입을 원하는 대로 체이닝 할수 있는 점은 좋은 점이다. 또한 객체 지향 언어중에 객체 상속과 추상화팩토링 작업을 하지 않아도 된다. 편하다는 점이다. 하지만 그만큼 많은 객체가 복사되었을때 객체의 인스턴스끼리 연결성으로 인한 메모리 릭등을 고려해야 되고 기존 객체의 프로토타입을 건드려 버리면 안정적인 앱을 실행하기 어렵다.

### 불변, 가변 객체 설명
객체를 참조하면 원본 참조하여 할당된 값이 변하면 그 변수는 해싱한 데이터 (1개의 주소만가짐 현제는) 를 변형하게 된다. 이는 가변성을 띈다고 할 수있다. 이러한 문제로 인하여 원시데이터가 참조 되지 않고 객체가 참조되있다면 그 객체가 변형되면 원본도 같이 변형된다. 이를 방지하기 위해 방어적 복사를 활용하여 객체를 복사하여 사용하거나 freeze메서드를 활용하여 객체 속성을 변경불가능하게 바꿀수 있다. 

### __proto__ 와 prototype의 차이는?

둘다 참조객체는 맞다. 하지만 prototype은 복사전 원형 객체의 공유속성이고, __proto__는 복재(파생)된 객체의 공유속성이다.


### 테스트 자동화 종류(TDD, BDD, DDD 등) 및 설명


### 안드로이드, IOS 에 대한 테스팅 방법 및 다르게 구현해야 하는 이슈 경험 사례


### 브라우저 지원 범위 및 설정 이유

### 주소를 칠때부터 사용자에게 보여질때까지 웹페이지가 렌더링 되는 과정 설명


### SSL에 대한 전반적인 설명


### HTTP 헤더값 중 connection의 keep-alive 속성 설명


### RESTFul CRUD 메소드에 대한 및 설명 : GET, POST, PUT, DELETE


### 세션 쿠키 설명


### HTTP 응답코드 200, 300, 400, 500번대별 설명

### React의 state와 구 AngularJS의 2 Way 바인딩의 차이

### 점진적 향상과 우아한 낮춤 설명