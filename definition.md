# 컴파일 언어 vs 인터프리터 언어

컴파일 언어는 자료형과 함수의 인풋 아웃풋의 타입, 클래스의 인터페이스등 정의 할수 있기 때문에 좀 더 안정적으로 로직을 구현할수 있습니다. 대표적으로 java, scala, 등등

인터프리터 언어는 상대적으로 해석기(자바스크립크 엔진)가 소스코드를 실행하면서 번수, 함수 자료형이 결정되어 실행되어 로직이 복잡해 진다면 특수한 상황에서 에러가 날 가능성을 내포하고 있습니다.

컴파일 언어에 대한 것은 전문가가 아니기 때문에 인터프리터 언의 장단점만 서술하려 합니다.

## 장점
- 빠른개발이 가능하다. 타입, 인터페이스 선인이 불필요하다. (타입스크립트의 경우는 논외)
- 배우기 쉽다. 실제로 많은 개발자들이 가능 쉽다고 생각하는 언어가 자바스크립트임.
- 컴파일 시간이 없어 실행 시간이 비교적 빠르다.
- 디버깅환경을 구성하기 편하다.
- 생성된 코드를 실행 할때마다 번역하므로 구조적으로 잘 짜여 있으면 메모리를 효율적으로 관리 할수 있다.
- 많은 사용자가 있는 만큼 네트워크가 많이 발달 되어 있다. (개인적으로 가장큰 장점이라고 생각. NPM 킹왕짱)
- WIP...

## 단점
- 실행 과정에서 형태가 정해지기 때문에 내가 원했던 결과가 안나올수 있는 위험성을 내포 하고 있고, 자체적으로도 논리적으로 맞지 않는 부분이 존재 했었다.(현재는 많이 발전하고 있다.)
- 컴파일러는 초기 실행이 느리지만 로직상 메모리 누수가 없다면 느려지는 경우는 없지만, 자바스크립트에서는 실행 되지 않는 객체, 자료등이 자동으로 메모리에 할상 해제 되(가비지컬렉션)때문에 메모리관리에 둔감해지면 메모리 관리에 소흘해 지기 쉽다.
- 소스코드가 노출되기 때문에 중요한 비지니스 로직을 쉽게 노출 할 수 있다.
- 라이브러리를 추가 하지 않는 이상 사용하는 메서드가 다른 언어에 비해서 적은 편이다.
- WIP...




# 자료형

## 기본형과 참조형의 차이
기본형의 경우는 변수에 그값을 저장하는 방법이지만 참조형의 경우 데이타의 주소를 저장하는 방법입니다.
기본형의 경우는 데이타를 메모리에 저장하는 방법이 정해져 있기 때문에 가능합니다. 참조형의 경우는 어떻게 보면 자료구조체를 만드는것이라고 생각되기 때문에 참조형이 더 맞다고 생각되어 집니다.

## 객체 object [include Array]

객체는 키 값으로 식별 가능한 속성을 가지고 있는 바구니라고 생각하면 됩니다.
데이터 속성,
value => get으로 반환되는 값.
writable => 속성 변경 불/가
Enumerable =>  속성 루프에 열거 불/가
Configurable => 속성의 제거 & (value/writable) 수정 여부 불/가

접근자.
get => 인자의 목록 없이 함수 실행 반환 되는값 속성값.
set => 이속성을 바꾸려고 할떄마다 인자로 속성이 바꾸는 함수.
Enumerable => 루프에 열거 불/가
Configurable => 제거. 수정 불/가

### Array
정수인 키를 가지는 일련의 값들을 표현하기위한 오브젝트입니다. 오브젝트의 길이를 나타내는 length란 속성도 있습니다.

### function
함수는 일급 객체로 정보의 가공, 구성, 재사용을 가능하게 하는 모듈화의 근간입니다.
함수는 일반적으로 인자를 가지고 있고, 반환되는 값을 가지고 있습니다. 반환되는 값이 지정되지 않은 함수는 undefined 반환합니다.
함수는 고유의 스코프를 가지고 있습니다. 고유의 실행환경이 있기 때문에 모듈화를 구현하기 좋습니다.

#### 메소드와 함수의 차이
메소드는 객체안에서 위치하여 그 객체의 속성을 변경하고 객체의 기능으로 존재하며, 함수의 경우는 함수 자체가 고유의 기능을 가지고 있다는 것을 의미합니다.


#### context
콜스텍이라고도 하며, 함수가 호출된때 같이 생성되고 변수(내부 변수, 아큐먼트), this, 스콥(스콥체인)를 생성합니다.

#### scope
영향 끼치는 범위? 함수안에서 선언된 변수는 허용된 범위안에서만 영향을 끼칠수 있다. 하지만 그 범위는 스코프 체인에 의해서 결정된다.

##### scope 체인
함수는 실행 범위 안에서 실행한 함수안에서는 상위의 변경 탐색을 허용. 순서는 안쪽에서 바깥쪽을 향하고 있다.

#### lexical scope
스코프는 호출할때 생기지 않고 선언할때 생긴다 그래서 스코프는 항상 일정 하다. 만약 호출할때 생기면 코드를 정상적으로 짤 수가 없겠지? 그래서 변수가 탐색 허용된 위치가 자기가 현제 선언된 위치의 상위에 있다면 그 변수를 참조한다.

##### 호이스팅
함수가 context를 생성하며 scope를 정의할때 변수가 최우선적으로 생성해집니다. 이런 이유로
순서와 상관없이 선언구문을 최우선적으로 해석하는 것을 의미합니다.


#### method & argument (this)
함수가 실행되면 context=> this라는 함수 실행 주체가 생성됩니다. 로직을 구현하기 위해서는 this를 조작해야 하는 경우가 생기는데 그렇때 함수의 메소드 call, apply, bind를 사용할수 있습니다.
일단 call/apply의 경우는 함수를 호충할때 첫번째 인자에 this를 대체하기 위한 값을 넣어 호출합니다. 유사배열인 argument를 배열화 해서 사용할 수 있게 호출하여 사용하는 패턴이 자주 사용되어 집니다.
또한 컨텍스트를 마음대로 할수 있기 때문에 oop적인 코드를 생성할 수 있습니다.
bind의 경우 this만 대체하고 다른 일은 수행하지 않습니다.


#### 클로져
함수는 고유의 scope를 있으며 스코프체인으로 안에서 밖으로는 참조가 가능하지만 밖에서 안으로는 리턴하지 않은 값은 참조할수 없어, 은닉화에 이용되어 지는 기술.


### 복사
#### 얕은 복사
문자형, 숫자형 불린을 제외한 객체를 변수에 대입하면 값이 복사 되는것이 아니라 참조가 복사됩니다. 즉 주소만 복사한다는 말이라고 생각하면 됩니다.
일반 적으로 변수는 메모리에 저장되어 집니다. 그런 메모리에 있는 데이터의 고유 주소가 있고 이걸 참조하는 것이 고유주로를 통하여 접근하는 것입니다. 그러므로 일반적인 참조방법으로는 객체를 완전히 복제하여 새롭게
사용할 수 없습니다.
#### 깊은 복사
for문과 hasOwnProperty이용해서 깊은 복사 함수를 만들어서 구현 합니다. 아니면 람다나 로데시와 같은 함수 라이브러리를 이용해서 복사합니다.


### 호스트객체/ 네이티브 객체
호스트 객체는 사용자가 만들어낸 객체이고 네이비트 객체는 미리 생성되어 져있는 개체를 의미합니다.

## 숫자 number
다른 언어 처럼 숫자형만의 int, short, long, double 같은 구분이 없습니다. 자바스크립트 숫자형은 정수만을 표현하기 위한 특별한 자료형이 존재하지 않고, 항상 64비트 부동 소수점입니다.
숫자 (분수)(the fraction)은 0 부터 51 비트에 저장되며, 지수(the exponent)는 bits 52 부터 62 에, 부호(the sign)는 bit 63 에 저장합니다. 이렇게 64 비트에 저장되어 사용되어 지고 있씁니다.

##### 논쟁 (정확성)
정수의 경우는 최대 15자리 까지 정확하게 나타낼수 있습니다.
소수의 경우는 17자리 까지 나타내지만 신뢰성은 낮다고 할수 있기에 15자리 쯤으로 제한하는게 좋습니다.

#### 논쟁 (NaN)
숫자형에는 자바스크립트의 예약어 형태인 NaN이 할당 될수 있습니다.

#### tip.
10진수가 기본인 자바스크립트 숫자형을 16, 8, 2 진수로 구분하려면, toString(16) 등 메서드를 이용하면 알 수 있습니다.

## 문자 string
텍스트 데이터를 나타낸다. 16비트 부호없는 정수값의 집합이다. 각 string 요소는 각 string 위치를 나타낸다. 자바스크립트

## 불린 boolean
Boolean 은 논리적인 요소를 나타내고, true 와 false 의 두 가지 값을 가지고 있습니다.

## null / undefined
null = 의도적으로 비어있다는 의미입니다. 가장 중요한건 의도적이라는 것입니다.

undefined = 할당되지 않은 변수를 선언했을때 자바스크립트에서 자체적으로 할당하는 원시데이타형입니다.

## 심볼 Symbol

심볼은 유일하고 변경불가능한 immutable 기본값입니다.


# es6 & es7

## 블록 스코프
{} 감싸게 되면 별도의 스코프가 생성된디ㅏ.

## let, const
TDZ가 발생하지 않아 선언 하지 좀 더 직관적으로 변수를 생성할수 있습니다.
- let : 한번 선언하면 재선언은 안되고 값을 변경하는것은 가능
- const : 한번 선언하면 재선언, 값 변경이 불가능

## arrow function
순수 함수로써의 기능을 위해 만든 함수로 매게변수 리턴하는 형태를 간소화 시킬수 있는 형태의 신텍스 슈가입니다.

## rest param
함수의 파라미터를 동적으로 할당하기 위해 만들어진 기능입니다.

## default param
파라미터의 기본값을 설정하여 기능 구현을 좀더 편하게 해줍니다.

## property Shorthand
키값과 변수명이 동일한 경우 키를 생략 가능합니다.

## method Shorthand
메소드에 function을 생략 가능합니다.

## Destructuring Assignment
배열 혹은 객체를 해체하여 변수에 할당합니다.

## spread operator
문자열 단어, 배열, 객체 속성을 해체하여 반환해줍니다.


## template literals
템플릿 리터럴로 새로운 형태의 문자열로 띄어쓰기 엔터등을 인식합니다.


## class
자바의 클래스를 모티브로 만든 신텍스 슈가입니다. 하지만 private등은 완벽히 구현되어 있지 않습니다.
### static
클래스의 정적 속성과 메소드는 인스턴스화 없이 실행됩니다. 클래스의 인스턴스에서 호출 되지 않기 때문에 어플리케이션을 위한 유틸로써만 사용되어 집니다.
### extends 확장
부모를 상속받는 자식클래스를 만들어 질때 사용하며 자식에서 프로퍼티 초기화(construct)를 사용하기 위해선 super함수를 사용해야 합니다.

## import / export
es6의 새로운 모듈화 패턴입니다.


## array 메소드
### reduece
함수의 결과값을 이전 인자로 같는 방법으로 함수 체인이 되어 결과값을 얻을수 있습니다.
