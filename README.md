# 컴파일 언어 vs 인터프리터 언어

컴파일 언어는 자료형과 함수의 인풋 아웃풋의 타입, 클래스의 인터페이스등 정의 할수 있기 때문에 좀 더 안정적으로 로직을 구현할수 있습니다. 대표적으로 java, scala, 등등

인터프리터 언어는 상대적으로 해석기(자바스크립크 엔진)가 소스코드를 실행하면서 번수, 함수 자료형이 결정되어 실행되어 로직이 복잡해 진다면 특수한 상황에서 에러가 날 가능성을 내포하고 있습니다.

컴파일 언어에 대한 것은 전문가가 아니기 때문에 인터프리터 언의 장단점만 서술하려 합니다.

## 장점
- 빠른개발이 가능하다. 타입, 인터페이스 선인이 불필요하다. (타입스크립트의 경우는 논외)
- 배우기 쉽다. 실제로 많은 개발자들이 가능 쉽다고 생각하는 언어가 자바스크립트임.
- 컴파일 시간이 없어 실행 시간이 비교적 빠르다.
- 디버깅환경을 구성하기 편하다.
- 생성된 코드를 실행 할때마다 번역하므로 구조적으로 잘 짜여 있으면 메모리를 효율적으로 관리 할수 있다.
- 많은 사용자가 있는 만큼 네트워크가 많이 발달 되어 있다. (개인적으로 가장큰 장점이라고 생각. NPM 킹왕짱)
- WIP...

## 단점
- 실행 과정에서 형태가 정해지기 때문에 내가 원했던 결과가 안나올수 있는 위험성을 내포 하고 있고, 자체적으로도 논리적으로 맞지 않는 부분이 존재 했었다.(현재는 많이 발전하고 있다.)
- 컴파일러는 초기 실행이 느리지만 로직상 메모리 누수가 없다면 느려지는 경우는 없지만, 자바스크립트에서는 실행 되지 않는 객체, 자료등이 자동으로 메모리에 할상 해제 되기(가비지컬렉션)때문에 메모리관리에 둔감해지면 메모리 관리에 소흘해 지기 쉽다.
- 소스코드가 노출되기 때문에 중요한 비지니스 로직을 쉽게 노출 할 수 있다.
- 라이브러리를 추가 하지 않는 이상 사용하는 메서드가 다른 언어에 비해서 적은 편이다.
- WIP...




# 자료형

## 기본형과 참조형의 차이
기본형의 경우는 변수에 그값을 저장하는 방법이지만 참조형의 경우 데이타의 주소를 저장하는 방법입니다.
기본형의 경우는 데이타를 메모리에 저장하는 방법이 정해져 있기 때문에 가능합니다. 참조형의 경우는 어떻게 보면 자료구조체를 만드는것이라고 생각되기 때문에 참조형이 더 맞다고 생각되어 집니다.

## 객체 object [include Array]

객체는 키 값으로 식별 가능한 속성을 가지고 있는 바구니라고 생각하면 됩니다.
데이터 속성,
value => get으로 반환되는 값.
writable => 속성 변경 불/가
Enumerable =>  속성 루프에 열거 불/가
Configurable => 속성의 제거 & (value/writable) 수정 여부 불/가

접근자.
get => 인자의 목록 없이 함수 실행 반환 되는값 속성값.
set => 이속성을 바꾸려고 할떄마다 인자로 속성이 바꾸는 함수.
Enumerable => 루프에 열거 불/가
Configurable => 제거. 수정 불/가

### Array
정수인 키를 가지는 일련의 값들을 표현하기위한 오브젝트입니다. 오브젝트의 길이를 나타내는 length란 속성도 있습니다.

### function
함수는 일급 객체로 정보의 가공, 구성, 재사용을 가능하게 하는 모듈화의 근간입니다.
함수는 일반적으로 인자를 가지고 있고, 반환되는 값을 가지고 있습니다. 반환되는 값이 지정되지 않은 함수는 undefined 반환합니다.
함수는 고유의 스코프를 가지고 있습니다. 고유의 실행환경이 있기 때문에 모듈화를 구현하기 좋습니다.

#### 메소드와 함수의 차이
메소드는 객체안에서 위치하여 그 객체의 속성을 변경하고 객체의 기능으로 존재하며, 함수의 경우는 함수 자체가 고유의 기능을 가지고 있다는 것을 의미합니다.


#### context
콜스텍이라고도 하며, 함수가 호출된때 같이 생성되고 변수, this, argument, scope를 생성합니다.

#### scope
함수는 실행 범위를 가지고 있습니다.
##### scope 체인
함수는 실행 범위 안에서 실행한 함수안에서는 상위의 탐색을 허용합니다. 순서는 안쪽에서 바깥쪽을 향하고 있습니다.
##### 호이스팅
함수가 context를 생성하며 scope를 정의할때 변수가 최우선적으로 생성해집니다. 이런 이유로
순서와 상관없이 선언구문을 최우선적으로 해석하는 것을 의미합니다.

#### lexical scope
자바스크립트는 콜스텍과 관련없이 소스코드가 작성된 컨텍스트기준으로 스코프를 정의하고 런타임에 반영하지 않습니다.
함수안에서는 소스코드가 작성된 컨텍스트 기분으로 스코프를 정의하기 때문에 만약 함수안에서 다른 함수를 정의하고 호출한 함수에서 값을 변경한다고 해서 호출한 함수안의 값은 변경할 수 없습니다.

#### method & argument (this)
함수가 실행되면 context=> this라는 함수 실행 주체가 생성됩니다. 로직을 구현하기 위해서는 this를 조작해야 하는 경우가 생기는데 그렇때 함수의 메소드 call, apply, bind를 사용할수 있습니다.
일단 call/apply의 경우는 함수를 호충할때 첫번째 인자에 this를 대체하기 위한 값을 넣어 호출합니다. 유사배열인 argument를 배열화 해서 사용할 수 있게 호출하여 사용하는 패턴이 자주 사용되어 집니다.
또한 컨텍스트를 마음대로 할수 있기 때문에 oop적인 코드를 생성할 수 있습니다.
bind의 경우 this만 대체하고 다른 일은 수행하지 않습니다.


#### 클로져
함수는 고유의 scope를 있으며 스코프체인으로 안에서 밖으로는 참조가 가능하지만 밖에서 안으로는 리턴하지 않은 값은 참조할수 없어, 은닉화에 이용되어 지는 기술입니다.


### 복사
#### 얕은 복사
문자형, 숫자형 불린을 제외한 객체를 변수에 대입하면 값이 복사 되는것이 아니라 참조가 복사됩니다. 즉 주소만 복사한다는 말이라고 생각하면 됩니다.
일반 적으로 변수는 메모리에 저장되어 집니다. 그런 메모리에 있는 데이터의 고유 주소가 있고 이걸 참조하는 것이 고유주로를 통하여 접근하는 것입니다. 그러므로 일반적인 참조방법으로는 객체를 완전히 복제하여 새롭게
사용할 수 없습니다.
#### 깊은 복사
for문과 hasOwnProperty이용해서 깊은 복사 함수를 만들어서 구현 합니다. 아니면 람다나 로데시와 같은 함수 라이브러리를 이용해서 복사합니다.


### 호스트객체/ 네이티브 객체
호스트 객체는 사용자가 만들어낸 객체이고 네이비트 객체는 미리 생성되어 져있는 개체를 의미합니다.

## 숫자 number
다른 언어 처럼 숫자형만의 int, short, long, double 같은 구분이 없습니다. 자바스크립트 숫자형은 정수만을 표현하기 위한 특별한 자료형이 존재하지 않고, 항상 64비트 부동 소수점입니다.
숫자 (분수)(the fraction)은 0 부터 51 비트에 저장되며, 지수(the exponent)는 bits 52 부터 62 에, 부호(the sign)는 bit 63 에 저장합니다. 이렇게 64 비트에 저장되어 사용되어 지고 있씁니다.

##### 논쟁 (정확성)
정수의 경우는 최대 15자리 까지 정확하게 나타낼수 있습니다.
소수의 경우는 17자리 까지 나타내지만 신뢰성은 낮다고 할수 있기에 15자리 쯤으로 제한하는게 좋습니다.

#### 논쟁 (NaN)
숫자형에는 자바스크립트의 예약어 형태인 NaN이 할당 될수 있습니다.

#### tip.
10진수가 기본인 자바스크립트 숫자형을 16, 8, 2 진수로 구분하려면, toString(16) 등 메서드를 이용하면 알 수 있습니다.

## 문자 string
텍스트 데이터를 나타낸다. 16비트 부호없는 정수값의 집합이다. 각 string 요소는 각 string 위치를 나타낸다. 자바스크립트

## 불린 boolean
Boolean 은 논리적인 요소를 나타내고, true 와 false 의 두 가지 값을 가지고 있습니다.

## null / undefined
null = 의도적으로 비어있다는 의미입니다. 가장 중요한건 의도적이라는 것입니다.

undefined = 할당되지 않은 변수를 선언했을때 자바스크립트에서 자체적으로 할당하는 원시데이타형입니다.

## 심볼 Symbol

심볼은 유일하고 변경불가능한 immutable 기본값입니다.











# 이벤트
## 이벤트 등록/해제
인터렉티브만 어플리케이션을 제작하기 위해선 이벤트라는 계념이 필요합니다. 보통 addEventListener() 웹 api를 이용해서 등록하고 removeEventListener()로 헤제합니다.

## 이벤트 버블링/캡쳐링 propagation
addEventListener() 함수의 세번째 인자로 결정됩니다. true => 캡처링, false => 버블링
### 버블링
부모와 자식 노드가 있다고 가정하고 자식 노드에서 이벤트가 실행되었다면, 부모로 이벤트가 전파 된다는것입니다.

### 캡쳐링
위와 반대로 부모에 이벤트가 자식으로 전파되는 과정을 말합니다.

### preventDefault와 stopPropagation, stopImmediatePropagation
이벤트를 관리하면서 가장 많이 문제가 되는 부분이 위와 같이 이벤트가 전파되는걸 컨트롤 하지 못하는 케이스입니다.
위의 이벤트 메소드를 이용해서 문제 해결이 가능합니다.
- preventDefault => dom의 고유 동작을 중지 시킴
- stopPropagation => 이번트 전파를 중지 시킴
- stopImmediatePropagation => 이벤트 전파를 중지 시키며, dom에 등록된 동일한 동작의 이벤트를 실행 시키지 않음

## 이벤트 위임 delegatoin
이벤트를 등록하면 할수록 메모리의 누수를 걱정해야 할수 있습니다. 그러므로 상위의 엘리먼트에 이벤트를 위임함으로써 동적 엘리먼스트의 이벤트를 처리를 수월하게 알수 있고 자유업게 삭제 등록 할수 있습니다.
보통 엘리먼트 id를 통해서 관리하는 패턴이 통용되고 있다.

## 쓰로틀링 / 디바운싱
자바스크립트는 여러가지 방법론이 존재하지만 엄밀히 말하면 싱글 스레드 언어입니다.
현대의 어플리케이션은 동적인 페이지가 많고 비동기통신이 많아져 스택오버플로우 호출스택이 가득차 버리는 에러가 발생할수 있습니다. 이런걸 해결하고자 나온 방법론입니다.
- 쓰로틀린 : 마지막 함수가 호출된 후 일정한 시간이 지나기 전에 다시 호출되지 않도록 하여 스택오버플로우를 해결합니다.
- 디바운싱 : 연이어 호출되는 함수등 중 마지막 함수만 호출하는 기법

## document ready와 load의 차이
dom 트리가 만들어지면 발생하는 이벤트에서 리소스를 다 다운로드 받은 상태가 load이고 dom 트리만 생성된 상태가 ready입니다.
그러므로 ready 상태에서 이벤트가 생성된다면, 오류를 일으키게 됩니다.

## FOUC

Flash Of Unstyled Content의 약자로 dom이 다 불러오기전에 리소스를 모드 불어오지 못해 나타나는 현상으로 css를 head안에 넣어줌으로 해결 할수 있고,
자바스크립트로 동적으로 표현한 사이트라면 리소스를 다 받기고 준비전에는 로딩바를 이용하는 것도 좋은 방법이다.


# 변수...

로직을 구현할때 특정 정보를 담아 저장해야 컨트롤 할수 있습니다.
자바스크립트는 변수를 선언 한다는 계념이라고 생각했지만, 좀 더 공부해 보니 유효범위를 지정하는 역할을 수행한다고 보는게 더 적절하다고 생각하게 되었습니다.







# 패턴

## 프로토타입 패턴 (생성자 패턴)
상속이란 계념의 기반하여 만들어진 패턴 상속에 의하여 얕은 복제본으로써 좀 더 효율적인 코딩이 가능하게 해줍니다.
### 프로토타입 체인이란
객체의 속성을 사용할때 고유의 속성이 없다면 __proto_의 속성을 이용해 자신의 생성에 관여한 생성자 함수의 속성을 탐색하여 속성을 가지고 옵니다.

### 상속
어떤 객체를 생성하게 되고 그생선된 객체의 기능을 물려받은 또다른 객체를 생성하게 된다는 것을 의합니다. 이것은 확장이라고 표현 할수도 있습니다.
자바스크립트에는 확장을 위한 문법이 따로 존재 하지는 않기 때문에 프로토타입을 이용하여 상속의 기능을 만들어 냅니다. 부모의 객체의 속성과 메서드를
그대로 참조한 얕은 복사의 계념으로 자식 객체를 생성 할수 있습니다.

## 싱글톤 패턴
싱글톤(singleton) 패턴은 전체 시스템에서 하나의 인스턴스만 존재하도록 보장하는 객체 생성패턴을 말합니다. 네임 스페이스 패턴을 만들고자 할때 응용 되어 집니다.

## 네임스페이스 패턴
자바스크립트는 내부 메소드가 부족하고 협업과정에서 여러가지 모듈이 혼합될수 있습니다. 전역 콘텍스트에 동일한 이름 가지는 모듈이 존재한다면 오류를 일으킬수 있기때문에, 교유의 네임스페이스를 정의해
독립성을 보장하고 신뢰성을 확보힙니다.

## 추상팩토리 패턴
어떤 공통된 시스템 객체를 찍어내기 위한 패턴

## 프록시 패턴
프록시 패턴을 사용자가 원하는 행동을 하기전에 기억된 행동을 해서 성능을 높이는 방법입니다.

## 옵저버 패턴
...




# 함수형 프로그래밍
일단 함수형 프로그래밍은 상태기반으로 생각하지 말고 입출력을 기반으로 데이타를 흐르는 길을 어떤식으로 조합할지에 대한 이론으로 생각하는게 좋을것 같습니다.
원칙으로는 인자를 꼭 받아야하고 리턴하는 값이 꼭 이어야 한다는 점입니다. 인자를 제외한 다른 변수는 사용하면 안됩니다. 인자만으로 결과를 만들어야 합니다. 예를 들어서
map, filter, reduce등의 메소드등이 있습니다.
es6에서 순수함수를 만들기 위한 신텍스 슈거인 arrow function이 있습니다.

## 고차 함수
인풋과 아웃풋에 함수를 이용함으로써 확장성을 확보하는 패턴으리고 할수 있다.

## 커링 (고차함수 응용)
다중인자를 받는 함수를 단일 인자 함수로 만드로 만들어 내는 것. 함수가 함수를 만들어 내는 기법 즉, 함수가 함수를 리턴하는 방법입니다.
부분적으로 적용된 함수를 체인으로 계속 생성해 결과적으로 값을 처리하도록 하는 것입니다. reduce 함수를 예로 들을수도 있습니다.




# AJAX 비동기 통신
XMLHttpRequest를 이용하여 비동기 방식으로 서버와 통신하는 방법으로 이방법을 이용해 내부족으로 response를 받아 동적으로 데이트를 핸들링 하게 되어 페이지 새로고침을 하지 않고 fetch를 합니다.
## JSONP
ajax는 크로스도메인이 허용하지 않기 때문에 사용하는 기술로, script 코드가 돔에 추가되면 외부 스크립트를 로드할수 있으므로, 외부 스크립트를 호출하면서 함수를 명시해 줘서 콜백함수를 실행해서 데이타를 바인딩 하는 방법입니다.
## promise
콜백 함수로 처리하면 되는 문제였지만 요즘에는 프론트엔드의 규모가 커지면서 코드의 복잡도가 높아지는 콜백 지옥이 발생하게 됩니다.
이런 상황에서 등장한 것이 promise 입니다. 비동기 작업을 병렬로 혹은 순차적으로 진행할 수 있게 되었습니다. 하지만 더 좋은 방법인 async awiat가 나와
좀 더 깔끔한 코드를 만들어 낼수 있게 되었습니다.




# TDD
테스트 주도형 개발 방법론으로 어떤 기능이 필요하면 그 요구사항에 테스트를 만들어 통과하는 코드를 작성하고 상황에 맞게 점점 리팩토링 해 나가는 방식입니다.

## 테스트 코드작성방법론
1=>100으로 되는 방식으로 점점 테스트케이스를 늘려가면서 기능을 검증하며, 로직을 단단하게 해나가야 합니다.
또한 모든 상황에 테스트 코드를 작성하기 보단 메소드에 하나 작성한다는 마음으로 하되 비지니스 로직에 불빌요한 테스트코드는 작성하지 않도록 주의해야 할것 같습니다.

# es6 & es7

## 블록 스코프
{} 감싸게 되면 별도의 스코프가 생성된디ㅏ.

## let, const
TDZ가 발생하지 않아 선언 하지 좀 더 직관적으로 변수를 생성할수 있습니다.
- let : 한번 선언하면 재선언은 안되고 값을 변경하는것은 가능
- const : 한번 선언하면 재선언, 값 변경이 불가능

## arrow function
순수 함수로써의 기능을 위해 만든 함수로 매게변수 리턴하는 형태를 간소화 시킬수 있는 형태의 신텍스 슈가입니다.

## rest param
함수의 파라미터를 동적으로 할당하기 위해 만들어진 기능입니다.

## default param
파라미터의 기본값을 설정하여 기능 구현을 좀더 편하게 해줍니다.

## property Shorthand
키값과 변수명이 동일한 경우 키를 생략 가능합니다.

## method Shorthand
메소드에 function을 생략 가능합니다.

## Destructuring Assignment
배열 혹은 객체를 해체하여 변수에 할당합니다.

## spread operator
문자열 단어, 배열, 객체 속성을 해체하여 반환해줍니다.


## template literals
템플릿 리터럴로 새로운 형태의 문자열로 띄어쓰기 엔터등을 인식합니다.


## class
자바의 클래스를 모티브로 만든 신텍스 슈가입니다. 하지만 private등은 완벽히 구현되어 있지 않습니다.
### static
클래스의 정적 속성과 메소드는 인스턴스화 없이 실행됩니다. 클래스의 인스턴스에서 호출 되지 않기 때문에 어플리케이션을 위한 유틸로써만 사용되어 집니다.
### extends 확장
부모를 상속받는 자식클래스를 만들어 질때 사용하며 자식에서 프로퍼티 초기화(construct)를 사용하기 위해선 super함수를 사용해야 합니다.

## import / export
es6의 새로운 모듈화 패턴입니다.


## array 메소드
### reduece
함수의 결과값을 이전 인자로 같는 방법으로 함수 체인이 되어 결과값을 얻을수 있습니다.
